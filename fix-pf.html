<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>How to fix PartialFunction</title>
  <meta name="description" content="Presented at Scala World, 2nd Sept 2019">
  <meta name="author" content="Dale Wijnand">

  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/black.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/monokai.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>

  <style>
  .reveal a {
    opacity: 0.75;
    color: #FF9800;
  }
  .reveal pre code.hljs {
    display: block;
  }
  code.hljs {
    display: inline;
    padding: 0;
  }
  </style>
</head>
<body>
<div class="reveal">
<div class="slides">
<section data-markdown><script type="text/template">

## How to totally fix PartialFunction

Dale Wijnand (<a href="http://twitter.com/dwijnand">@dwijnand</a>)
Scala World, 2nd Sept 2019
<https://github.com/dwijnand/talks/fix-pf.html>

</script></section><section data-markdown><script type="text/template">

First: `Function1` <!-- .element: class="hljs" --> ([doc][F1-scaladoc]/[src][F1-source]):
```scala
trait Function1[-A, +B] {
  def apply(a: A): B
}
```
and its special type alias:
```scala
type A => B = Function1[A, B]
```
special because it's right-associative:
```scala
A => B => C
// means
A => (B => C)
```

[F1-scaladoc]: https://www.scala-lang.org/api/2.13.0/scala/Function1.html
[F1-source]: https://github.com/scala/scala/blob/v2.13.0/src/library/scala/Function1.scala

</script></section><section data-markdown><script type="text/template">

Now: `PartialFunction` ([doc][PF-scaladoc]/[src][PF-source]):
```scala
trait PartialFunction[-A, +B] extends (A => B) {
  def isDefinedAt(a: A): Boolean
}
```
I often type alias `PartialFunction`.  Ideally I'd like:
```scala
type A ?=> B = PartialFunction[A, B]
```
But to make it right-associative, like `=>`, I'll use:
```scala
type A ?=>: B = PartialFunction[A, B]
```

[PF-scaladoc]: https://www.scala-lang.org/api/2.13.0/scala/PartialFunction.html
[PF-source]: https://github.com/scala/scala/blob/v2.13.0/src/library/scala/PartialFunction.scala

</script></section><section data-markdown><script type="text/template">

How `PartialFunction` is/should be implemented:
```scala
trait PartialFunction[-A, +B] extends (A => B) {  
  def isDefinedAt(a: A): Boolean = ...

  def apply(a: A): B = {
    if (isDefinedAt(a)) { ... }
    else throw new MatchError(...)
  }
}
```

</script></section><section data-markdown><script type="text/template">

The rest of `Function1`:

```scala
trait Function1[-A, +B] {
  def apply(a: A): B

  def andThen[C](g: B => C): A => C = a => g(apply(a))
  def compose[R](g: R => A): R => B = r => apply(g(r))

  // actually an extension method in `object Function1`
  def unlift[T](implicit ev: B <:< Option[T]): A ?=>: T
}
```

</script></section><section data-markdown><script type="text/template">

The rest of `PartialFunction` (1/2):

```scala
trait PartialFunction[-A, +B] extends (A => B) {  
  def andThen[C](g: B  =>  C): A ?=>: C
  def andThen[C](g: B ?=>: C): A ?=>: C
  def compose[R](g: R ?=>: A): R ?=>: B
  def orElse[A1 < A, B1 >: B](g: A1 ?=>: A2): A1 ?=>: B1

  def lift: A => Option[B]
  def unapply(a: A): Option[B] = lift(a)
  def elementWise = new ElementWiseExtractor(this)
}
```

</script></section><section data-markdown><script type="text/template">

The rest of `PartialFunction` (2/2):

```scala
trait PartialFunction[-A, +B] extends (A => B) {  
  def applyOrElse[A1 <: A, B1 >: B](a: A1, alt: A1 => B1) = {
    if (isDefinedAt(a)) apply(a) else alt(a)
  }

  def runWith[U](action: B => U): A => Boolean =
    (a: A) => {
      val b: B = applyOrElse(a, checkFallback[B])
      if (fallbackOccurred(b)) false else {
        action(b)
        true
      }
    }
}
```

</script></section>
</div>
</div>

<script src="js/reveal.js"></script>

<script>
  // More info about config & dependencies:
  // - https://github.com/hakimel/reveal.js#configuration
  // - https://github.com/hakimel/reveal.js#dependencies
  Reveal.initialize({
    dependencies: [
      { src: 'plugin/markdown/marked.js' },
      { src: 'plugin/markdown/markdown.js' },
      { src: 'plugin/notes/notes.js', async: true },
      { src: 'plugin/highlight/highlight.js', async: true }
    ],
    slideNumber: true,
    history: true,
    transition: 'fade',
    markdown: {
      breaks: true
    }

  });
</script>
</body>
</html>
