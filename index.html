<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>How to fix PartialFunction</title>
  <meta name="description" content="Presented at Scala World, 2nd Sept 2019">
  <meta name="author" content="Dale Wijnand">

  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/black.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/monokai.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>

  <style>
  .reveal a {
    opacity: 0.75;
    color: #FF9800;
  }
  </style>
</head>
<body>
<div class="reveal">
<div class="slides">
<section>
<section data-markdown><script type="text/template">

## How to totally fix PartialFunction

Dale Wijnand (<a href="http://twitter.com/dwijnand">@dwijnand</a>)
Scala World, 2nd Sept 2019
<https://github.com/dwijnand/talks/fix-pf.html>

</script></section><section data-markdown><script type="text/template">

## Agenda

* Definitions
* Usage
* Implementation
* Problem(s)
* Proposal
* Summary

</script></section>
</section>

<section>
<section data-markdown><script type="text/template">

## Definitions

So how is `Function1` defined? ([doc][F1-scaladoc]/[src][F1-source]):
```scala
trait Function1[-A, +B] {
  def apply(a: A): B
}
```
but we know it by its infix type alias:
```scala
type A => B = Function1[A, B] // =>[A, B]
```
which is special, because it's right-associative:
```scala
A => B => C
// means
A => (B => C)
```

[F1-scaladoc]: https://www.scala-lang.org/api/2.13.0/scala/Function1.html
[F1-source]: https://github.com/scala/scala/blob/v2.13.0/src/library/scala/Function1.scala

</script></section><section data-markdown><script type="text/template">

## Definitions

And how is `PartialFunction` defined? ([doc][PF-scaladoc]/[src][PF-source]):
```scala
trait PartialFunction[-A, +B] extends (A => B) {
  def isDefinedAt(a: A): Boolean
}
```
I often type alias it.  Ideally I'd like:
```scala
type A ?=> B = PartialFunction[A, B]
```
(in the past I've also used this alternative:)
```scala
type A =?> B = PartialFunction[A, B]
```
But to make it right-associative, like `=>`, I'll use:
```scala
type A ?=>: B = PartialFunction[A, B]
```

[PF-scaladoc]: https://www.scala-lang.org/api/2.13.0/scala/PartialFunction.html
[PF-source]: https://github.com/scala/scala/blob/v2.13.0/src/library/scala/PartialFunction.scala

</script></section><section data-markdown><script type="text/template">

## Definitions

`Function1` also has some methods (combinators):

```scala
trait Function1[-A, +B] {
  def andThen[C](g: B => C): A => C = a => g(apply(a))
  def compose[R](g: R => A): R => B = r => apply(g(r))
}
```

</script></section><section data-markdown><script type="text/template">

## Definitions

and now `PartialFunction`'s methods (1/2):

```scala
trait PartialFunction[-A, +B] extends (A => B) {  
  def andThen[C](g: B  =>  C): A ?=>: C
  def andThen[C](g: B ?=>: C): A ?=>: C
  def compose[R](g: R ?=>: A): R ?=>: B
  def orElse[A1 < A, B1 >: B](g: A1 ?=>: B1): A1 ?=>: B1

  def lift: A => Option[B] // and `.unlift` to go back
  def unapply(a: A): Option[B] = lift(a)
  def elementWise = new ElementWiseExtractor(this)
  ...
}
```

</script></section><section data-markdown><script type="text/template">

## Definitions

The rest of `PartialFunction` (2/2):

```scala
trait PartialFunction[-A, +B] extends (A => B) {  
  def applyOrElse[A1 <: A, B1 >: B](a: A1, alt: A1 => B1) = {
    if (isDefinedAt(a)) apply(a) else alt(a)
  }

  def runWith[U](action: B => U): A => Boolean =
    (a: A) => {
      val b: B = applyOrElse(a, checkFallback[B])
      if (!fallbackOccurred(b)) {
        action(b)
        true
      } else false
    }
}
```

</script></section><section data-markdown><script type="text/template">

## Definitions

There are also utility methods on `PartialFunction`'s companion object (1/2):
```scala
object PartialFunction {
  def empty[A, B]: A ?=>: B

  def fromFunction[A, B](f: A => B): A ?=>: B =
    { case a => f(a) }

  def cond[A](a: A)(pf: A ?=>: Boolean): Boolean =
    pf.applyOrElse(a, constFalse)

  def condOpt[A, B](a: A)(pf: A ?=>: B]): Option[B] =
    pf.lift(a)

  ...
}
```

</script></section><section data-markdown><script type="text/template">

## Definitions

There are also utility methods on `PartialFunction`'s companion object (2/2):
```scala
object PartialFunction {
  ...

  private val fallback_fn: Any => Any =
    _ => fallback_fn

  private def checkFallback[B]: Any => B =
    fallback_fn.asInstanceOf[Any => B]

  private def fallbackOccurred[B](b: B): Boolean =
    fallback_fn.eq(b.asInstanceOf[AnyRef])
}
```

</script></section>
</section>

<section><section data-markdown><script type="text/template">

## Usage

So when do you want to use `PartialFunction`?

I know two general use cases

</script></section><section data-markdown><script type="text/template">

## Usage

1) when you want to operate on only part of the input

without addition runtime costs (`Option` boxing)

For example, mapping on only part of the elements:

```scala
xs.collect { case s if s.startsWith("FOO_") => ... }
```

or handling only part of the actor messages:

```scala
def receive = {
  case Deposit(amt)  => ???
  case Withdraw(amt) => ???
  // missing: CheckBalance
}
```

</script></section><section data-markdown><script type="text/template">

## Usage

2) when you want to define individual partial functions

and then combine them with `orElse`:

```scala
myFuture.recoverWith(
  onNoUser.orElse(onNoToken).orElse(recordIncident)
)
```

</script></section>
</section>

<section><section data-markdown><script type="text/template">

## Implementation

So given an expression like:

```scala
param => selector match { cases }
```

what's the resulting `PartialFunction`?

</script></section><section data-markdown><script type="text/template">

## Implementation

First off: `apply` must honour `isDefinedAt`:

```scala
... extends trait PartialFunction[..., ...] {
  def isDefinedAt(a: A): Boolean = ...

  def apply(a: A): B = {
    if (isDefinedAt(a)) { ... }
    else throw new MatchError(...)
  }
}
```

</script></section><section data-markdown><script type="text/template">

## Implementation

but that would make `applyOrElse` expensive:

```scala
... extends PartialFunction[..., ...] {
  def isDefinedAt(a: A): Boolean = ...

  def apply(a: A): B = {
    if (isDefinedAt(a)) { ... }
    else throw new MatchError(...)
  }

  // this is the default implementation in PartialFunction
  def applyOrElse[A1 <: A, B1 >: B](a: A1, alt: A1 => B1) = {
    if (isDefinedAt(a)) apply(a) else alt(a)
  }
}
```

</script></section><section data-markdown><script type="text/template">

## Implementation

So instead the compiler generates:

```scala
... extends AbstractPartialFunction[..., ...] {
  def apply(x: A): B = // defined in AbstractPartialFunction
    applyOrElse(x, PartialFunction.empty)

  def isDefinedAt(a: A): Boolean =
    $selector match { $casesTrue; case _ => false }

  def applyOrElse[A1 <: A, B1 >: B](a: A1, alt: A1 => B1) =
    $selector match { $cases; case _ => alt(x) }
}
```

</script></section>
</section>

<section><section data-markdown><script type="text/template">

## Problem(s)

This has been discussed for a number of years

Mostly that it doesn't make sense mathematically:

total functions are a subset of partial functions

And therefore `Function1` should extends `PartialFunction` instead

</script></section><section data-markdown><script type="text/template">

## Problem(s)

The counter is from an object-oriented point-of-view

`PartialFunction` adds `isDefinedAt`

And therefore it makes sense that `PartialFunction` extends `Function1`

(Perhaps rename it `QueryableFunction`)

</script></section><section data-markdown><script type="text/template">

## Problem(s)

The problem with this counter-argument is:

_it changes the expectations of `apply`_

Now, there are no totality guarantees in Scala

There's no guarantee that `Function1` doesn't throw

But there is an _assumption_ that a `A => B` is total

Or at least defined for "most" values

</script></section><section data-markdown><script type="text/template">

## Problem(s)

Here's an example of such an expectation:

```scala
scala> List("FOO_A", "BAR_B").map {
     |   case s if s.startsWith("FOO_") => s
     | }
scala.MatchError: BAR_B (of class java.lang.String)
  at .$anonfun$res0$1(<console>:1)
  at scala.collection.immutable.List.map(List.scala:226)
  ... 58 elided
```

</script></section><section data-markdown><script type="text/template">

## Problem(s)

`PartialFunction`'s addition of `isDefinedAt`

along with the ergonomic syntax for defining them

changes the expectations of `apply`

Suddenly it's _more likely_ that `apply` isn't defined

</script></section><section data-markdown><script type="text/template">

## Problem(s)

To put it another way:

Given a value of type `Function1[..., ...]`

* Is calling `apply` safe?
* Should I check `isInstanceOf[PartialFunction[_, _]]`?
* Should I just `try`/`catch` it?

</script></section><section data-markdown><script type="text/template">

## Problem(s)

Additionally there's another smaller problem,

in that requiring a partial function affects ergonomics

```scala
scala> Try[Int](???).recover(_ => 1)
                               ^
       error: type mismatch;
        found   : Throwable => Int
        required: PartialFunction[Throwable,?]

scala> Try[Int](???).recover { case _ => 1 }
res1: scala.util.Try[Int] = Success(1)
```
</script></section><section data-markdown><script type="text/template">

## Problem(s)

That one I've actually fix

See [scala/scala#8172][]

"Synthesize a PartialFunction from function literal"

Coming in Scala 2.13.1

[scala/scala#8172]: https://github.com/scala/scala/pull/8172

</script></section>
</section>

<section><section data-markdown><script type="text/template">

## Proposal

So the ideal setup is, really, quite simple

You need two changes:

1. Function1 extends PartialFunction
2. No `apply` on `PartialFunction`

</script></section><section data-markdown><script type="text/template">

## Proposal

So something like this:

```scala
trait PartialFunction[-A, +B] {
  def isDefinedAt(a: A): Boolean

  /** Call ONLY if `isDefinedAt` is `true` for `a`! */
  def unsafeApply(a: A): B

  def applyOrElse[A1 <: A, B1 >: B](a: A1, alt: A1 => B1) =
    if (isDefinedAt(a)) unsafeApply(a) else alt(a)
}

trait Function1[-A, +B] extends PartialFunction[A, B] {
  final def isDefinedAt(a: A) = true
  final def apply(a: A): B    = unsafeApply(a)
}
```

</script></section><section data-markdown><script type="text/template">

## Proposal

Note how `Function1` is still a SAM type.

And how `Function1`'s `apply` is cheap

it doesn't have to execute `isDefinedAt`

</script></section><section data-markdown><script type="text/template">

## Proposal

With that implementation everything gets simpler

You can pass `Function1` values

where `PartialFunction` values are expected

And the combinators (`andThen`, `orElse`, etc)

are much simpler

</script></section><section data-markdown><script type="text/template">

## Proposal

Now how do we get there?

well that's a lot harder...

I sanity-checked my idea with the Scala Team

and with Martin Odersky

and there doesn't seem to be anything I've missed

</script></section><section data-markdown><script type="text/template">

## Proposal

My first idea was this:

Introduce a new "partial function"

as a super-type of `Function1`

and eventually deprecate `PartialFunction`

and just lose the name "PartialFunction"

</script></section><section data-markdown><script type="text/template">

## Proposal

```scala
trait PF[-A, +B] { // real name, but with the ?=> alias
  def isDefinedAt(a: A): Boolean
  def unsafeApply(a: A): B

  def applyOrElse[A1 <: A, B1 >: B](a: A1, alt: A1 => B1) =
    if (isDefinedAt(a)) unsafeApply(a) else alt(a)
}

trait Function1[-A, +B] extends (A ?=> B) {
  final def isDefinedAt(a: A) = true
  final def unsafeApply(a: A) = apply(a)
}

trait PartialFunction[-A, +B] extends (A => B)
```

</script></section><section data-markdown><script type="text/template">

## Proposal

and then what?

In some version of Scala

`{ case ... => ... }` generates a `PF`

instead of `PartialFunction`?

:-/

</script></section><section data-markdown><script type="text/template">

## Proposal

Another idea is to drop the inheritance instead

So introduce `unsafeApply` on `PartialFunction`

and override `apply` to `@deprecate` it

</script></section><section data-markdown><script type="text/template">

## Proposal

It means creating `PartialFunction` values

when you have a `Function1` value

So maybe add `asPartial` on `Function1`

Or you can just use eta-expansion (thanks to my PR):

```scala
Try[Int](???).recover(fallback.asPartial)
Try[Int](???).recover(fallback(_))
```

You can also implement both traits

if you have a seq of 1000 values used both ways

</script></section><section data-markdown><script type="text/template">

## Proposal

The final idea is...

Create an unboxed `Option` with opaque types

Let's call it `Opt`

and now instead of `A ?=> B` you just require `A ?=> Opt[B]`

now no more boxing cost

and build your own `orElse` based on that

Need to study unboxed, opaque type Options in Dotty

</script></section>
</section>

<section><section data-markdown><script type="text/template">

## Summary

WDYT?

</script></section>
</section>
</div>
</div>

<script src="js/reveal.js"></script>

<script>
  // More info about config & dependencies:
  // - https://github.com/hakimel/reveal.js#configuration
  // - https://github.com/hakimel/reveal.js#dependencies
  Reveal.initialize({
    dependencies: [
      { src: 'plugin/markdown/marked.js' },
      { src: 'plugin/markdown/markdown.js' },
      { src: 'plugin/notes/notes.js', async: true },
      { src: 'plugin/highlight/highlight.js', async: true }
    ],
    slideNumber: true,
    history: true,
    // transition: 'fade',
    markdown: {
      breaks: true
    }

  });
</script>
</body>
</html>
